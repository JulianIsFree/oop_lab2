Проект MVS gtest.

Идея организации проекта именно в таком разделении была наглым образом
позаимствована у языка Java.

Back-end:
	Самый важный класс - WorkflowCompiler; Он (используя WorkflowTextProcessor) читает
	файл с исходным кодом и строит промежуточное представление программы (используя WorkflowParser) 
	в виде Block'ов (Block.h).
	Далее это промежуточное представление программы будет передано front-end части.

Front-end:
	Класс Builder ориентирован на построение из промежуточного представления в виде Block'ов
	нового представления в виде Worker'ов (WorkflowWorker'ов),
	которое будет исполнено Executor'ом (в нашем случае WorkflowWorkerExecutor'ом).

	Почему бы сразу не строить представление, которое нужно для исполнения Executor'ом?
	Потому что Block'и используются парсером и компилятором для анализа исходного кода, а 
	Worker'ы используются для его исполнения, если соединить эти два класса в один, то, во-первых,
	лишний раз пересекутся back-end и front-end (и в чем их смысл тогда?), а во вторых в каждой из 
	*-end частей не будет использоваться какая-то часть класса.

Одно большое "WorkflowProgramm" объединяет back-end и front-end в одну программу, своеобразный
main() этого проекта, он же принимает аргументы и спускает их к Builder'у на обработку (пункт 2б).

int main() находится в WorkflowProgramm.cpp 